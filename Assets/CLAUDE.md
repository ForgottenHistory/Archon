# Dominion - Claude Development Guide

## Project Overview
Dominion is a grand strategy game capturing ancient political realities - where every decision creates winners and losers among your subjects. Success comes from understanding internal dynamics, not just optimizing abstract numbers.

**CRITICAL**: Built on **dual-layer architecture** with deterministic simulation (CPU) + high-performance presentation (GPU). This enables 10,000+ provinces at 200+ FPS with multiplayer compatibility.

You, Claude, cannot run tests. I run them manually.

## CORE ARCHITECTURE: DUAL-LAYER SYSTEM

### **Layer 1: Simulation (CPU)**
```csharp
// EXACTLY 8 bytes - never change this size
[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct ProvinceState {
    public ushort ownerID;      // 2 bytes
    public ushort controllerID; // 2 bytes
    public byte development;    // 1 byte
    public byte terrain;        // 1 byte
    public byte fortLevel;      // 1 byte
    public byte flags;          // 1 byte
}

// 10,000 provinces × 8 bytes = 80KB total simulation state
```

### **Layer 2: Presentation (GPU)**
```csharp
// GPU textures for rendering
Texture2D provinceIDTexture;    // 46MB - which pixel = which province
Texture2D provinceOwnerTexture; // 3MB - who owns each province
Texture2D provinceColors;       // 1MB - visual colors
RenderTexture borderTexture;    // 8MB - generated via compute shader
```

## ARCHITECTURE ENFORCEMENT

### **NEVER DO THESE:**
- ❌ **Process millions of pixels on CPU** - use GPU compute shaders always
- ❌ **Dynamic collections in simulation** - fixed-size structs only
- ❌ **GameObjects for provinces** - textures only
- ❌ **Allocate during gameplay** - pre-allocate everything
- ❌ **Store history in hot path** - use cold data separation
- ❌ **Texture filtering on province IDs** - point filtering only
- ❌ **CPU neighbor detection** - GPU compute shaders for borders

### **ALWAYS DO THESE:**
- ✅ **8-byte fixed structs** for simulation state
- ✅ **GPU compute shaders** for all visual processing
- ✅ **Single draw call** for entire map
- ✅ **Deterministic operations** for multiplayer
- ✅ **Hot/cold data separation** for performance
- ✅ **Command pattern** for state changes

## PERFORMANCE TARGETS (NON-NEGOTIABLE)

### Memory Usage
- **Simulation**: 80KB (10k provinces × 8 bytes)
- **GPU Textures**: <60MB total
- **System Total**: <100MB

### Performance
- **Single-Player**: 200+ FPS with 10,000 provinces
- **Multiplayer**: 144+ FPS with network sync
- **Province Selection**: <1ms response time
- **Border Generation**: <1ms via compute shader

### Network (Multiplayer)
- **Bandwidth**: <5KB/s per client
- **State Sync**: 80KB for full game state
- **Command Size**: 8-16 bytes typical

## CODE STANDARDS

### Performance Requirements
- **Burst compilation** for all hot paths
- **Zero allocations** during gameplay
- **Fixed-size data structures** only
- **SIMD optimization** where possible
- **Native Collections** over managed collections

### File Organization
- **Single responsibility** per file
- **Under 500 lines** per file
- **Focused, modular** design
- **Clear separation** of concerns

### Unity Configuration
- **URP** (Universal Render Pipeline)
- **IL2CPP** scripting backend
- **Linear color space**
- **Burst Compiler** enabled
- **Job System** for parallelism

## CRITICAL DATA FLOW

```
Input → Command → Simulation State → GPU Textures → Render
         ↓           ↓                    ↓
      Network    Save/Load           Visual Effects
```

### Simulation → GPU Pipeline
```csharp
// 1. Update simulation (deterministic)
provinceStates[id] = newState; // 8 bytes

// 2. Update GPU texture (presentation)
ownerTexture.SetPixel(x, y, newOwnerColor);

// 3. GPU compute shader processes borders
borderComputeShader.Dispatch(threadGroups);

// 4. Single draw call renders everything
Graphics.DrawMesh(mapQuad, mapMaterial);
```

## TEXTURE-BASED MAP SYSTEM

### Core Concept
```
Traditional: Province → GameObject → Mesh → Draw Call (10k draw calls)
Our System:  Province → Texture Pixel → Shader → Single Draw Call
```

### Texture Formats
- **Province IDs**: R16G16 (point filtering, no mipmaps)
- **Province Owners**: R16 (updated from simulation)
- **Colors**: RGBA32 palette texture
- **Borders**: R8 (generated by compute shader)

### Compute Shader Pattern
```hlsl
[numthreads(8,8,1)]
void BorderDetection(uint3 id : SV_DispatchThreadID) {
    uint currentProvince = DecodeProvinceID(ProvinceIDTexture[id.xy]);
    uint rightProvince = DecodeProvinceID(ProvinceIDTexture[id.xy + int2(1,0)]);

    bool isBorder = currentProvince != rightProvince;
    BorderTexture[id.xy] = isBorder ? 1.0 : 0.0;
}
```

## MULTIPLAYER ARCHITECTURE

### Deterministic Simulation
```csharp
// All clients run identical simulation
public struct ProvinceCommand {
    public uint tick;           // When to execute
    public ushort provinceID;   // Which province
    public ushort newOwnerID;   // New state
    public uint checksum;       // Validation
}
```

### Network Optimization
- **Delta compression** - only send changes
- **Command batching** - multiple commands per packet
- **Priority system** - important changes first
- **Rollback support** - for lag compensation

## DEVELOPMENT WORKFLOW

### Before Writing Code:
1. **Check architecture compliance** - does this fit dual-layer?
2. **Verify performance impact** - will this scale to 10k provinces?
3. **Consider multiplayer** - is this deterministic?
4. **Plan memory usage** - fixed-size or dynamic?

### Code Quality Checklist:
- [ ] Uses 8-byte fixed structs for simulation
- [ ] GPU operations for visual processing
- [ ] Deterministic for multiplayer
- [ ] No allocations during gameplay
- [ ] Burst compilation compatible
- [ ] Under 500 lines per file

## TESTING STRATEGY

### Unit Tests Focus
- **Simulation determinism** - same input = same output
- **Serialization integrity** - round-trip state correctly
- **Command validation** - reject invalid commands
- **Memory bounds** - never exceed 100MB target

### Performance Tests
- **Scale testing** - 1k, 5k, 10k, 20k provinces
- **Frame time consistency** - no spikes
- **Memory stability** - no leaks over time
- **GPU utilization** - efficient compute shader usage

### Integration Tests
- **CPU→GPU pipeline** - simulation updates textures correctly
- **Input system** - mouse clicks map to correct provinces
- **Command system** - state changes propagate properly

## KEY REMINDERS

1. **Always ask about architecture compliance** before implementing
2. **Never suggest CPU processing** of millions of pixels
3. **Always consider multiplayer implications** of design choices
4. **Enforce the 8-byte struct limit** for simulation state
5. **GPU compute shaders** are the solution for visual processing
6. **Fixed-size data structures** are required for performance
7. **Single draw call rendering** is the target architecture

The success of this project depends on strict adherence to the dual-layer architecture. Every code change must support both 10,000+ province performance AND multiplayer determinism.