// Owner Texture Population Compute Shader for Dominion Map System
// Populates ProvinceOwnerTexture from province ownership data
// Runs entirely on GPU for maximum performance with 10,000+ provinces
// Architecture: CPU simulation data â†’ GPU texture (dual-layer architecture)

#pragma kernel PopulateOwners

// Input textures
Texture2D<float2> ProvinceIDTexture;  // RG16 format - which province at each pixel (2 channels)

// Input buffers
StructuredBuffer<uint> ProvinceOwnerBuffer;  // Owner ID per province (indexed by province ID)

// Output texture
RWTexture2D<float2> ProvinceOwnerTexture;  // RG16 format - owner ID at each pixel (R=low byte, G=high byte)

// Map dimensions
uint MapWidth;
uint MapHeight;

// Province ID decoding - must match BorderDetection.compute exactly
uint DecodeProvinceID(float2 encoded)
{
    // Convert from float [0,1] back to uint16 values
    uint r = (uint)(encoded.r * 255.0 + 0.5);
    uint g = (uint)(encoded.g * 255.0 + 0.5);

    // Reconstruct 16-bit province ID from RG channels
    return (g << 8) | r;
}

// Encode owner ID to RG16 format
float2 EncodeOwnerID(uint ownerID)
{
    // Encode as RG16: Store full 16-bit value in RG channels
    uint r = ownerID & 0xFF;        // Low byte (R channel)
    uint g = (ownerID >> 8) & 0xFF; // High byte (G channel)

    // Return as normalized float2 for RG16 format
    return float2(r / 255.0, g / 255.0);
}

// Thread group size - 8x8 = 64 threads per group
// This is optimal for most modern GPUs and matches BorderDetection.compute
[numthreads(8, 8, 1)]
void PopulateOwners(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= MapWidth || id.y >= MapHeight)
        return;

    // Sample province ID at this pixel
    float2 provinceEncoded = ProvinceIDTexture[id.xy];  // Returns float2 directly from RG16 texture
    uint provinceID = DecodeProvinceID(provinceEncoded);

    // Look up owner ID from buffer
    // Buffer is indexed by province ID, contains owner ID for each province
    uint ownerID = 0;  // Default to unowned

    // Bounds check for buffer access (assuming max 65536 provinces)
    if (provinceID < 65536)
    {
        ownerID = ProvinceOwnerBuffer[provinceID];
    }

    // Encode and write owner ID to texture
    // Write directly to id.xy (no Y-flip) - fragment shader handles coordinate conversion with (1.0 - uv.y)
    ProvinceOwnerTexture[id.xy] = EncodeOwnerID(ownerID);
}