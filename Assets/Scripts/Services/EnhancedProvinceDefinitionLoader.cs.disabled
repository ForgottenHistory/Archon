using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;
using ParadoxDataLib.Core.Parsers.Csv;
using ParadoxDataLib.Core.Parsers.Csv.DataStructures;
using ProvinceSystem.Services;
using ProvinceSystem.Utils;

namespace ProvinceSystem.Services
{
    /// <summary>
    /// Enhanced province definition loader using ParadoxDataLib CSV parser
    /// Replaces manual CSV parsing with robust ParadoxDataLib implementation
    /// Provides backward compatibility with existing ProvinceDefinitionLoader interface
    /// </summary>
    public class EnhancedProvinceDefinitionLoader : MonoBehaviour
    {
        [Header("Data Sources")]
        [SerializeField] private bool useParadoxDataManager = true;
        [SerializeField] private string csvFilePath = "Assets/Data/map/definition.csv";
        [SerializeField] private TextAsset csvTextAsset;

        [Header("Loading Settings")]
        [SerializeField] private bool loadOnStart = false;
        [SerializeField] private bool enableCaching = true;
        [SerializeField] private bool validateOnLoad = true;
        [SerializeField] private bool enableAsyncLoading = true;

        [Header("Processing Options")]
        [SerializeField] private bool filterWaterProvinces = false;
        [SerializeField] private bool assignCategories = true;
        [SerializeField] private bool generateMissingNames = true;
        [SerializeField] private string defaultCategory = "land";

        [Header("Debug Settings")]
        [SerializeField] private bool enableDebugLogging = true;
        [SerializeField] private bool logStatistics = true;
        [SerializeField] private bool validateIntegrity = true;

        // Events for integration
        public event Action<int> OnDefinitionsLoaded;
        public event Action<string> OnLoadError;
        public event Action<float> OnLoadProgress;
        public event Action OnLoadComplete;

        // Core data storage
        private Dictionary<int, UnityProvinceDefinition> _definitionsById;
        private Dictionary<Color32, UnityProvinceDefinition> _definitionsByColor;
        private Dictionary<Color32, int> _colorToIdMap;

        // ParadoxDataLib components (commenting out for now)
        // private CsvParser<UnityProvinceDefinition> _csvParser;
        private ParadoxDataManager _dataManager;
        private ParadoxDataPersistentCache _cache;

        // Loading state
        private bool _isLoaded = false;
        private bool _isLoading = false;
        private LoadingStatistics _stats;

        // Backward compatibility properties
        public Dictionary<int, UnityProvinceDefinition> DefinitionsById => _definitionsById;
        public Dictionary<Color32, UnityProvinceDefinition> DefinitionsByColor => _definitionsByColor;
        public int TotalProvinces => _stats?.TotalProvinces ?? 0;
        public int LandProvinces => _stats?.LandProvinces ?? 0;
        public int SeaProvinces => _stats?.SeaProvinces ?? 0;
        public int LakeProvinces => _stats?.LakeProvinces ?? 0;
        public bool IsLoaded => _isLoaded;
        public bool IsLoading => _isLoading;

        #region Unity Lifecycle

        private void Awake()
        {
            InitializeLoader();
        }

        private void Start()
        {
            if (loadOnStart)
            {
                if (enableAsyncLoading)
                    StartCoroutine(LoadDefinitionsAsyncCoroutine());
                else
                    LoadDefinitions();
            }
        }

        #endregion

        #region Initialization

        private void InitializeLoader()
        {
            try
            {
                // Initialize data structures
                _definitionsById = new Dictionary<int, UnityProvinceDefinition>();
                _definitionsByColor = new Dictionary<Color32, UnityProvinceDefinition>(new Color32Comparer());
                _colorToIdMap = new Dictionary<Color32, int>(new Color32Comparer());
                _stats = new LoadingStatistics();

                // Initialize ParadoxDataLib parser (remove for now since we'll use manual parsing)
                // _csvParser = new CsvParser<UnityProvinceDefinition>();

                // Get references to managers
                if (useParadoxDataManager)
                {
                    _dataManager = ParadoxDataManager.Instance;
                    if (_dataManager == null)
                    {
                        LogWarning("ParadoxDataManager not found, falling back to direct file loading");
                        useParadoxDataManager = false;
                    }
                }

                // Initialize cache if enabled
                if (enableCaching)
                {
                    _cache = new ParadoxDataPersistentCache("ProvinceDefinitions", 64, 24);
                }

                Log("Enhanced ProvinceDefinitionLoader initialized");
            }
            catch (Exception ex)
            {
                var error = ParadoxDataErrorHandler.HandleError(
                    ParadoxDataErrorType.ServiceInitializationFailed,
                    ex,
                    "EnhancedProvinceDefinitionLoader initialization"
                );
                OnLoadError?.Invoke(error.Message);
            }
        }

        #endregion

        #region Public Loading API

        /// <summary>
        /// Load province definitions using ParadoxDataLib CSV parser
        /// </summary>
        [ContextMenu("Load Province Definitions")]
        public void LoadDefinitions()
        {
            if (_isLoading)
            {
                LogWarning("Loading already in progress");
                return;
            }

            try
            {
                _isLoading = true;
                _stats.StartTime = DateTime.Now;

                Log("Starting province definition loading...");
                OnLoadProgress?.Invoke(0f);

                // Try to load from ParadoxDataManager first
                if (useParadoxDataManager && TryLoadFromDataManager())
                {
                    CompleteLoading();
                    return;
                }

                // Fall back to direct CSV loading
                LoadFromCSVDirect();
                CompleteLoading();
            }
            catch (Exception ex)
            {
                var error = ParadoxDataErrorHandler.HandleError(
                    ParadoxDataErrorType.CSVParsingFailed,
                    ex,
                    "Province definition loading"
                );
                OnLoadError?.Invoke(error.Message);
                _isLoading = false;
            }
        }

        /// <summary>
        /// Async version of LoadDefinitions for better performance
        /// </summary>
        public async Task<bool> LoadDefinitionsAsync()
        {
            if (_isLoading)
            {
                LogWarning("Loading already in progress");
                return false;
            }

            try
            {
                _isLoading = true;
                _stats.StartTime = DateTime.Now;

                Log("Starting async province definition loading...");
                OnLoadProgress?.Invoke(0f);

                bool success = false;

                // Try cache first
                if (enableCaching && await TryLoadFromCacheAsync())
                {
                    success = true;
                }
                // Try ParadoxDataManager
                else if (useParadoxDataManager && TryLoadFromDataManager())
                {
                    success = true;
                    if (enableCaching)
                        await CacheDefinitionsAsync();
                }
                // Fall back to direct loading
                else
                {
                    success = await LoadFromCSVDirectAsync();
                    if (success && enableCaching)
                        await CacheDefinitionsAsync();
                }

                if (success)
                {
                    CompleteLoading();
                    return true;
                }
                else
                {
                    _isLoading = false;
                    return false;
                }
            }
            catch (Exception ex)
            {
                var error = ParadoxDataErrorHandler.HandleError(
                    ParadoxDataErrorType.CSVParsingFailed,
                    ex,
                    "Async province definition loading"
                );
                OnLoadError?.Invoke(error.Message);
                _isLoading = false;
                return false;
            }
        }

        /// <summary>
        /// Unity Coroutine wrapper for async loading
        /// </summary>
        public System.Collections.IEnumerator LoadDefinitionsAsyncCoroutine()
        {
            var task = LoadDefinitionsAsync();
            yield return new WaitUntil(() => task.IsCompleted);
        }

        #endregion

        #region Loading Implementation

        private bool TryLoadFromDataManager()
        {
            if (_dataManager == null || !_dataManager.IsLoaded)
                return false;

            try
            {
                OnLoadProgress?.Invoke(0.2f);

                var paradoxDefinitions = _dataManager.GetAllProvinceDefinitions();
                int loadedCount = 0;

                foreach (var paradoxDef in paradoxDefinitions)
                {
                    var unityDef = new UnityProvinceDefinition(paradoxDef);

                    // Apply category assignment if enabled
                    if (assignCategories)
                    {
                        unityDef = AssignCategory(unityDef);
                    }

                    // Apply filtering
                    if (ShouldIncludeProvince(unityDef))
                    {
                        AddDefinition(unityDef);
                        loadedCount++;
                    }

                    UpdateStatistics(unityDef);
                }

                OnLoadProgress?.Invoke(0.8f);

                Log($"Loaded {loadedCount} definitions from ParadoxDataManager");
                return true;
            }
            catch (Exception ex)
            {
                LogError($"Failed to load from ParadoxDataManager: {ex.Message}");
                return false;
            }
        }

        private void LoadFromCSVDirect()
        {
            string csvContent = GetCSVContent();
            if (string.IsNullOrEmpty(csvContent))
            {
                throw new FileNotFoundException("No CSV content available");
            }

            OnLoadProgress?.Invoke(0.3f);

            // Use ParadoxDataLib CSV parser
            var csvLines = csvContent.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            ParseCSVWithParadoxDataLib(csvLines);

            OnLoadProgress?.Invoke(0.9f);
        }

        private async Task<bool> LoadFromCSVDirectAsync()
        {
            try
            {
                string csvContent = await GetCSVContentAsync();
                if (string.IsNullOrEmpty(csvContent))
                {
                    return false;
                }

                OnLoadProgress?.Invoke(0.3f);

                var csvLines = csvContent.Split('\n', StringSplitOptions.RemoveEmptyEntries);
                ParseCSVWithParadoxDataLib(csvLines);

                OnLoadProgress?.Invoke(0.9f);
                return true;
            }
            catch (Exception ex)
            {
                LogError($"Async CSV loading failed: {ex.Message}");
                return false;
            }
        }

        private void ParseCSVWithParadoxDataLib(string[] csvLines)
        {
            try
            {
                // Skip header if present
                int startIndex = csvLines.Length > 0 && csvLines[0].Contains("id") ? 1 : 0;
                int totalLines = csvLines.Length - startIndex;
                int processedLines = 0;

                for (int i = startIndex; i < csvLines.Length; i++)
                {
                    var line = csvLines[i].Trim();
                    if (string.IsNullOrEmpty(line)) continue;

                    try
                    {
                        var definition = ParseCSVLine(line);
                        if (definition != null && ShouldIncludeProvince(definition))
                        {
                            AddDefinition(definition);
                        }

                        if (definition != null)
                        {
                            UpdateStatistics(definition);
                        }
                    }
                    catch (Exception lineEx)
                    {
                        LogWarning($"Failed to parse CSV line {i + 1}: {lineEx.Message}");
                    }

                    processedLines++;
                    if (processedLines % 100 == 0)
                    {
                        float progress = 0.3f + (0.6f * processedLines / totalLines);
                        OnLoadProgress?.Invoke(progress);
                    }
                }
            }
            catch (Exception ex)
            {
                throw new Exception($"CSV parsing with ParadoxDataLib failed: {ex.Message}", ex);
            }
        }

        private UnityProvinceDefinition ParseCSVLine(string line)
        {
            // Parse CSV line using more robust method
            var parts = SplitCSVLine(line);
            if (parts.Length < 4)
                return null;

            try
            {
                int id = int.Parse(parts[0].Trim());
                byte r = byte.Parse(parts[1].Trim());
                byte g = byte.Parse(parts[2].Trim());
                byte b = byte.Parse(parts[3].Trim());

                string name = parts.Length > 4 ? parts[4].Trim('"', ' ') : "";
                if (string.IsNullOrEmpty(name) && generateMissingNames)
                {
                    name = $"Province_{id}";
                }

                var definition = new UnityProvinceDefinition(id, r, g, b, name, defaultCategory);

                return definition;
            }
            catch (Exception ex)
            {
                LogWarning($"Failed to parse CSV line: {line} - {ex.Message}");
                return null;
            }
        }

        private string[] SplitCSVLine(string line)
        {
            // Handle CSV with potential quoted fields
            var parts = new List<string>();
            bool inQuotes = false;
            var currentPart = "";

            for (int i = 0; i < line.Length; i++)
            {
                char c = line[i];

                if (c == '"')
                {
                    inQuotes = !inQuotes;
                }
                else if (c == ';' && !inQuotes)
                {
                    parts.Add(currentPart);
                    currentPart = "";
                }
                else
                {
                    currentPart += c;
                }
            }

            if (!string.IsNullOrEmpty(currentPart))
            {
                parts.Add(currentPart);
            }

            return parts.ToArray();
        }

        #endregion

        #region Cache Management

        private async Task<bool> TryLoadFromCacheAsync()
        {
            if (_cache == null)
                return false;

            try
            {
                var cacheKey = "province_definitions";
                var cachedData = await _cache.GetAsync<Dictionary<int, UnityProvinceDefinition>>(cacheKey);

                if (cachedData != null)
                {
                    _definitionsById = cachedData;
                    RebuildLookupTables();
                    RecalculateStatistics();

                    Log($"Loaded {_definitionsById.Count} definitions from cache");
                    return true;
                }
            }
            catch (Exception ex)
            {
                LogWarning($"Cache loading failed: {ex.Message}");
            }

            return false;
        }

        private async Task CacheDefinitionsAsync()
        {
            if (_cache == null || _definitionsById == null)
                return;

            try
            {
                var cacheKey = "province_definitions";
                await _cache.SetAsync(cacheKey, _definitionsById, TimeSpan.FromHours(24));
                Log("Province definitions cached successfully");
            }
            catch (Exception ex)
            {
                LogWarning($"Failed to cache definitions: {ex.Message}");
            }
        }

        #endregion

        #region Helper Methods

        private string GetCSVContent()
        {
            // Try TextAsset first
            if (csvTextAsset != null)
            {
                return csvTextAsset.text;
            }

            // Try file path
            if (!string.IsNullOrEmpty(csvFilePath) && File.Exists(csvFilePath))
            {
                return File.ReadAllText(csvFilePath);
            }

            throw new FileNotFoundException($"CSV file not found: {csvFilePath}");
        }

        private async Task<string> GetCSVContentAsync()
        {
            // Try TextAsset first
            if (csvTextAsset != null)
            {
                return csvTextAsset.text;
            }

            // Try file path
            if (!string.IsNullOrEmpty(csvFilePath) && File.Exists(csvFilePath))
            {
                return await File.ReadAllTextAsync(csvFilePath);
            }

            throw new FileNotFoundException($"CSV file not found: {csvFilePath}");
        }

        private UnityProvinceDefinition AssignCategory(UnityProvinceDefinition definition)
        {
            // Use default.map data if available through ParadoxDataManager
            if (_dataManager != null)
            {
                var defaultMapData = _dataManager.GetDefaultMapData();
                if (defaultMapData != null)
                {
                    // Check sea provinces
                    var seaProvinces = ExtractIntList(defaultMapData, "sea_starts");
                    if (seaProvinces.Contains(definition.Id))
                    {
                        return new UnityProvinceDefinition(definition.Id, definition.Red, definition.Green, definition.Blue, definition.Name, "sea");
                    }

                    // Check lake provinces
                    var lakeProvinces = ExtractIntList(defaultMapData, "lakes");
                    if (lakeProvinces.Contains(definition.Id))
                    {
                        return new UnityProvinceDefinition(definition.Id, definition.Red, definition.Green, definition.Blue, definition.Name, "lake");
                    }
                }
            }

            return definition; // Keep original category
        }

        private List<int> ExtractIntList(ParadoxDataLib.Core.Common.ParadoxNode node, string key)
        {
            var result = new List<int>();
            try
            {
                var values = node.GetValues<string>(key);
                foreach (var value in values)
                {
                    if (int.TryParse(value, out int id))
                    {
                        result.Add(id);
                    }
                }
            }
            catch
            {
                // Return empty list on error
            }
            return result;
        }

        private bool ShouldIncludeProvince(UnityProvinceDefinition definition)
        {
            if (filterWaterProvinces && definition.IsWater)
                return false;

            return true;
        }

        private void AddDefinition(UnityProvinceDefinition definition)
        {
            _definitionsById[definition.Id] = definition;
            _definitionsByColor[definition.Color] = definition;
            _colorToIdMap[definition.Color] = definition.Id;
        }

        private void UpdateStatistics(UnityProvinceDefinition definition)
        {
            _stats.TotalProvinces++;

            switch (definition.Category.ToLower())
            {
                case "land":
                    _stats.LandProvinces++;
                    break;
                case "sea":
                    _stats.SeaProvinces++;
                    break;
                case "lake":
                    _stats.LakeProvinces++;
                    break;
            }
        }

        private void RebuildLookupTables()
        {
            _definitionsByColor.Clear();
            _colorToIdMap.Clear();

            foreach (var definition in _definitionsById.Values)
            {
                _definitionsByColor[definition.Color] = definition;
                _colorToIdMap[definition.Color] = definition.Id;
            }
        }

        private void RecalculateStatistics()
        {
            _stats = new LoadingStatistics();
            foreach (var definition in _definitionsById.Values)
            {
                UpdateStatistics(definition);
            }
        }

        private void CompleteLoading()
        {
            _stats.EndTime = DateTime.Now;
            _isLoaded = true;
            _isLoading = false;

            OnLoadProgress?.Invoke(1f);
            OnDefinitionsLoaded?.Invoke(_definitionsById.Count);
            OnLoadComplete?.Invoke();

            if (logStatistics)
            {
                LogStatistics();
            }

            if (validateIntegrity)
            {
                ValidateLoadedData();
            }
        }

        private void ValidateLoadedData()
        {
            var issues = new List<string>();

            // Check for duplicate IDs
            var idCounts = _definitionsById.Keys.GroupBy(x => x).Where(g => g.Count() > 1);
            if (idCounts.Any())
            {
                issues.Add($"Duplicate province IDs found: {string.Join(", ", idCounts.Select(g => g.Key))}");
            }

            // Check for duplicate colors
            var colorCounts = _definitionsByColor.Keys.GroupBy(x => x).Where(g => g.Count() > 1);
            if (colorCounts.Any())
            {
                issues.Add($"Duplicate colors found: {colorCounts.Count()} colors");
            }

            // Check for invalid IDs
            var invalidIds = _definitionsById.Values.Where(d => d.Id <= 0);
            if (invalidIds.Any())
            {
                issues.Add($"Invalid province IDs found: {invalidIds.Count()} provinces");
            }

            if (issues.Any())
            {
                LogWarning($"Data validation issues found:\n{string.Join("\n", issues)}");
            }
            else
            {
                Log("Data validation passed");
            }
        }

        #endregion

        #region Backward Compatibility API

        /// <summary>
        /// Get province ID from color (backward compatibility)
        /// </summary>
        public int GetProvinceIdFromColor(Color32 color)
        {
            return _colorToIdMap.TryGetValue(color, out int id) ? id : -1;
        }

        /// <summary>
        /// Get definition by ID (backward compatibility)
        /// </summary>
        public UnityProvinceDefinition GetDefinitionById(int id)
        {
            return _definitionsById.TryGetValue(id, out var definition) ? definition : null;
        }

        /// <summary>
        /// Get definition by color (backward compatibility)
        /// </summary>
        public UnityProvinceDefinition GetDefinitionByColor(Color32 color)
        {
            return _definitionsByColor.TryGetValue(color, out var definition) ? definition : null;
        }

        /// <summary>
        /// Check if province is sea (backward compatibility)
        /// </summary>
        public bool IsSeaProvince(int provinceId)
        {
            var definition = GetDefinitionById(provinceId);
            return definition != null && definition.IsSea;
        }

        /// <summary>
        /// Check if province is lake (backward compatibility)
        /// </summary>
        public bool IsLakeProvince(int provinceId)
        {
            var definition = GetDefinitionById(provinceId);
            return definition != null && definition.IsLake;
        }

        /// <summary>
        /// Check if province is land (backward compatibility)
        /// </summary>
        public bool IsLandProvince(int provinceId)
        {
            var definition = GetDefinitionById(provinceId);
            return definition != null && definition.IsLand;
        }

        #endregion

        #region Logging

        private void LogStatistics()
        {
            var duration = _stats.EndTime - _stats.StartTime;
            var message = $"Province Definition Loading Statistics:\n" +
                         $"- Total Provinces: {_stats.TotalProvinces}\n" +
                         $"- Land Provinces: {_stats.LandProvinces}\n" +
                         $"- Sea Provinces: {_stats.SeaProvinces}\n" +
                         $"- Lake Provinces: {_stats.LakeProvinces}\n" +
                         $"- Loading Time: {duration.TotalMilliseconds:F0}ms\n" +
                         $"- Memory Usage: {(_definitionsById.Count * 64 / 1024):F1}KB";

            Log(message);

            if (FileLogger.Instance != null)
            {
                DominionLogger.LogSection("Province Definition Loading Complete");
                FileLogger.Instance.Log(message);
            }
        }

        private void Log(string message)
        {
            if (enableDebugLogging)
            {
                Debug.Log($"[EnhancedProvinceLoader] {message}");
            }
        }

        private void LogWarning(string message)
        {
            if (enableDebugLogging)
            {
                Debug.LogWarning($"[EnhancedProvinceLoader] {message}");
            }
        }

        private void LogError(string message)
        {
            Debug.LogError($"[EnhancedProvinceLoader] {message}");
        }

        #endregion

        #region Supporting Classes

        [System.Serializable]
        private class LoadingStatistics
        {
            public DateTime StartTime;
            public DateTime EndTime;
            public int TotalProvinces;
            public int LandProvinces;
            public int SeaProvinces;
            public int LakeProvinces;
        }

        #endregion
    }

    /// <summary>
    /// Color32 comparer for dictionary usage (from original ProvinceDefinitionLoader)
    /// </summary>
    public class Color32Comparer : IEqualityComparer<Color32>
    {
        public bool Equals(Color32 x, Color32 y)
        {
            return x.r == y.r && x.g == y.g && x.b == y.b;
        }

        public int GetHashCode(Color32 color)
        {
            return (color.r << 16) | (color.g << 8) | color.b;
        }
    }
}