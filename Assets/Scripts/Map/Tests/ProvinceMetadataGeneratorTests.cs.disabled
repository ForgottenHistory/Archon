using NUnit.Framework;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;
using Map.Province;
using Map.Loading;

namespace Map.Tests
{
    /// <summary>
    /// Tests for ProvinceMetadataGenerator functionality
    /// </summary>
    [TestFixture]
    public class ProvinceMetadataGeneratorTests
    {
        [Test]
        public void GenerateMetadata_SimpleSquareProvince_ShouldCalculateCorrectly()
        {
            // Create a simple 4x4 grid with a 2x2 square province in the center
            // Layout:
            // 0 0 0 0
            // 0 1 1 0
            // 0 1 1 0
            // 0 0 0 0
            const int width = 4, height = 4;
            var pixels = new NativeArray<ProvinceMapLoader.ProvincePixel>(width * height, Allocator.Temp);

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    int index = y * width + x;
                    ushort provinceID = (x >= 1 && x <= 2 && y >= 1 && y <= 2) ? (ushort)1 : (ushort)0;

                    pixels[index] = new ProvinceMapLoader.ProvincePixel
                    {
                        Position = new int2(x, y),
                        ProvinceID = provinceID,
                        Color = provinceID == 1 ? Color.red : Color.black
                    };
                }
            }

            try
            {
                var result = ProvinceMetadataGenerator.GenerateMetadata(CreateMockLoadResult(pixels, width, height), CreateMockNeighborResult());

                try
                {
                    Assert.IsTrue(result.Success, "Metadata generation should succeed");
                    Assert.AreEqual(2, result.ProvinceMetadata.Length, "Should have metadata for 2 provinces (0 and 1)");

                    // Find province 1's metadata
                    ProvinceMetadataGenerator.ProvinceMetadata province1Metadata = default;
                    bool foundProvince1 = false;

                    for (int i = 0; i < result.ProvinceMetadata.Length; i++)
                    {
                        if (result.ProvinceMetadata[i].ID == 1)
                        {
                            province1Metadata = result.ProvinceMetadata[i];
                            foundProvince1 = true;
                            break;
                        }
                    }

                    Assert.IsTrue(foundProvince1, "Should find metadata for province 1");

                    // Check pixel count (2x2 = 4 pixels)
                    Assert.AreEqual(4, province1Metadata.PixelCount, "Province 1 should have 4 pixels");

                    // Check center point (should be around 1.5, 1.5)
                    Assert.AreEqual(1.5f, province1Metadata.CenterPoint.x, 0.1f, "Center X should be around 1.5");
                    Assert.AreEqual(1.5f, province1Metadata.CenterPoint.y, 0.1f, "Center Y should be around 1.5");

                    // Check bounding box
                    Assert.AreEqual(1, province1Metadata.BoundingBox.Min.x, "Bounding box min X should be 1");
                    Assert.AreEqual(1, province1Metadata.BoundingBox.Min.y, "Bounding box min Y should be 1");
                    Assert.AreEqual(2, province1Metadata.BoundingBox.Max.x, "Bounding box max X should be 2");
                    Assert.AreEqual(2, province1Metadata.BoundingBox.Max.y, "Bounding box max Y should be 2");

                    // Should not have disconnected parts (single 2x2 square)
                    Assert.IsFalse(province1Metadata.HasDisconnectedParts, "Single square should not have disconnected parts");

                    Debug.Log($"Province 1: Center=({province1Metadata.CenterPoint.x:F2}, {province1Metadata.CenterPoint.y:F2}), " +
                              $"Pixels={province1Metadata.PixelCount}, BBox={province1Metadata.BoundingBox}");
                }
                finally
                {
                    result.Dispose();
                }
            }
            finally
            {
                pixels.Dispose();
            }
        }

        [Test]
        public void GenerateMetadata_DisconnectedProvince_ShouldDetectDisconnection()
        {
            // Create a province with two disconnected parts:
            // 1 0 1 0
            // 0 0 0 0
            // 0 0 0 0
            // 1 0 1 0
            const int width = 4, height = 4;
            var pixels = new NativeArray<ProvinceMapLoader.ProvincePixel>(width * height, Allocator.Temp);

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    int index = y * width + x;
                    ushort provinceID = 0;

                    // Create disconnected pattern
                    if ((x == 0 && y == 0) || (x == 2 && y == 0) ||
                        (x == 0 && y == 3) || (x == 2 && y == 3))
                    {
                        provinceID = 1;
                    }

                    pixels[index] = new ProvinceMapLoader.ProvincePixel
                    {
                        Position = new int2(x, y),
                        ProvinceID = provinceID,
                        Color = provinceID == 1 ? Color.red : Color.black
                    };
                }
            }

            try
            {
                var result = ProvinceMetadataGenerator.GenerateMetadata(CreateMockLoadResult(pixels, width, height), CreateMockNeighborResult());

                try
                {
                    Assert.IsTrue(result.Success, "Should handle disconnected provinces");

                    // Find province 1's metadata
                    ProvinceMetadataGenerator.ProvinceMetadata province1Metadata = default;
                    bool foundProvince1 = false;

                    for (int i = 0; i < result.ProvinceMetadata.Length; i++)
                    {
                        if (result.ProvinceMetadata[i].ID == 1)
                        {
                            province1Metadata = result.ProvinceMetadata[i];
                            foundProvince1 = true;
                            break;
                        }
                    }

                    Assert.IsTrue(foundProvince1, "Should find metadata for province 1");
                    Assert.IsTrue(province1Metadata.HasDisconnectedParts, "Should detect disconnected parts");
                    Assert.AreEqual(4, province1Metadata.PixelCount, "Should count all pixels in disconnected parts");

                    Debug.Log($"Disconnected province detected: {province1Metadata.DisconnectedPartCount} parts");
                }
                finally
                {
                    result.Dispose();
                }
            }
            finally
            {
                pixels.Dispose();
            }
        }

        [Test]
        public void GenerateMetadata_TerrainClassification_ShouldClassifyCorrectly()
        {
            // Create a simple province and test terrain classification
            const int width = 3, height = 3;
            var pixels = new NativeArray<ProvinceMapLoader.ProvincePixel>(width * height, Allocator.Temp);

            // Create a single province covering the entire 3x3 grid
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    int index = y * width + x;
                    pixels[index] = new ProvinceMapLoader.ProvincePixel
                    {
                        Position = new int2(x, y),
                        ProvinceID = 1,
                        Color = Color.green // Green for plains/grassland
                    };
                }
            }

            try
            {
                var result = ProvinceMetadataGenerator.GenerateMetadata(pixels, width, height, 1);

                try
                {
                    Assert.IsTrue(result.Success, "Terrain classification should succeed");
                    Assert.AreEqual(1, result.ProvinceMetadata.Length, "Should have metadata for 1 province");

                    var provinceMetadata = result.ProvinceMetadata[0];
                    Assert.AreEqual(1, provinceMetadata.ID, "Should be province 1");

                    // The exact terrain type depends on the implementation
                    // This is more of a smoke test to ensure classification doesn't crash
                    Debug.Log($"Terrain type: {provinceMetadata.TerrainType}");
                    Assert.IsTrue(System.Enum.IsDefined(typeof(ProvinceMetadataGenerator.TerrainType), provinceMetadata.TerrainType),
                                  "Should have valid terrain type");
                }
                finally
                {
                    result.Dispose();
                }
            }
            finally
            {
                pixels.Dispose();
            }
        }

        [Test]
        public void GenerateMetadata_ConvexHull_ShouldGenerateValidHull()
        {
            // Create an L-shaped province to test convex hull generation
            // Layout:
            // 1 1 0
            // 1 0 0
            // 1 1 1
            const int width = 3, height = 3;
            var pixels = new NativeArray<ProvinceMapLoader.ProvincePixel>(width * height, Allocator.Temp);

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    int index = y * width + x;
                    ushort provinceID = 0;

                    // L-shape pattern
                    if ((y == 0 && (x == 0 || x == 1)) ||  // Top row: first two
                        (y == 1 && x == 0) ||              // Middle row: first only
                        (y == 2))                          // Bottom row: all three
                    {
                        provinceID = 1;
                    }

                    pixels[index] = new ProvinceMapLoader.ProvincePixel
                    {
                        Position = new int2(x, y),
                        ProvinceID = provinceID,
                        Color = provinceID == 1 ? Color.red : Color.black
                    };
                }
            }

            try
            {
                var result = ProvinceMetadataGenerator.GenerateMetadata(CreateMockLoadResult(pixels, width, height), CreateMockNeighborResult());

                try
                {
                    Assert.IsTrue(result.Success, "Convex hull generation should succeed");

                    // Find province 1's metadata
                    ProvinceMetadataGenerator.ProvinceMetadata province1Metadata = default;
                    bool foundProvince1 = false;

                    for (int i = 0; i < result.ProvinceMetadata.Length; i++)
                    {
                        if (result.ProvinceMetadata[i].ID == 1)
                        {
                            province1Metadata = result.ProvinceMetadata[i];
                            foundProvince1 = true;
                            break;
                        }
                    }

                    Assert.IsTrue(foundProvince1, "Should find metadata for province 1");

                    // Convex hull should have at least 3 points
                    Assert.IsTrue(province1Metadata.ConvexHull.IsCreated, "Convex hull should be created");
                    Assert.GreaterOrEqual(province1Metadata.ConvexHull.Length, 3, "Convex hull should have at least 3 points");

                    Debug.Log($"Convex hull has {province1Metadata.ConvexHull.Length} points");

                    // Check that hull points are reasonable (within bounds)
                    for (int i = 0; i < province1Metadata.ConvexHull.Length; i++)
                    {
                        var point = province1Metadata.ConvexHull[i];
                        Assert.GreaterOrEqual(point.x, 0, "Hull point X should be >= 0");
                        Assert.GreaterOrEqual(point.y, 0, "Hull point Y should be >= 0");
                        Assert.Less(point.x, width, $"Hull point X should be < {width}");
                        Assert.Less(point.y, height, $"Hull point Y should be < {height}");
                    }
                }
                finally
                {
                    result.Dispose();
                }
            }
            finally
            {
                pixels.Dispose();
            }
        }

        [Test]
        public void GenerateMetadata_EmptyInput_ShouldFail()
        {
            var emptyPixels = new NativeArray<ProvinceMapLoader.ProvincePixel>(0, Allocator.Temp);

            try
            {
                var result = ProvinceMetadataGenerator.GenerateMetadata(emptyPixels, 0, 0, 0);

                Assert.IsFalse(result.Success, "Should fail with empty input");
                Assert.IsNotEmpty(result.ErrorMessage, "Should have error message");

                result.Dispose();
            }
            finally
            {
                emptyPixels.Dispose();
            }
        }

        [Test]
        public void GenerateMetadata_InvalidDimensions_ShouldFail()
        {
            var pixels = new NativeArray<ProvinceMapLoader.ProvincePixel>(4, Allocator.Temp);

            // Fill with dummy data
            for (int i = 0; i < 4; i++)
            {
                pixels[i] = new ProvinceMapLoader.ProvincePixel
                {
                    Position = new int2(i % 2, i / 2),
                    ProvinceID = 1,
                    Color = Color.red
                };
            }

            try
            {
                // Wrong dimensions: claiming 3x3 (9 pixels) but only have 4 pixels
                var result = ProvinceMetadataGenerator.GenerateMetadata(pixels, 3, 3, 1);

                Assert.IsFalse(result.Success, "Should fail with mismatched dimensions");
                Assert.IsNotEmpty(result.ErrorMessage, "Should have error message");

                result.Dispose();
            }
            finally
            {
                pixels.Dispose();
            }
        }

        [Test]
        public void GenerateMetadata_LargeProvince_ShouldPerformReasonably()
        {
            // Create a larger test province (50x50 square)
            const int size = 50;
            var pixels = new NativeArray<ProvinceMapLoader.ProvincePixel>(size * size, Allocator.Temp);

            for (int y = 0; y < size; y++)
            {
                for (int x = 0; x < size; x++)
                {
                    int index = y * size + x;
                    pixels[index] = new ProvinceMapLoader.ProvincePixel
                    {
                        Position = new int2(x, y),
                        ProvinceID = 1,
                        Color = Color.red
                    };
                }
            }

            try
            {
                var stopwatch = System.Diagnostics.Stopwatch.StartNew();
                var result = ProvinceMetadataGenerator.GenerateMetadata(pixels, size, size, 1);
                stopwatch.Stop();

                try
                {
                    Assert.IsTrue(result.Success, "Large province metadata generation should succeed");
                    Assert.AreEqual(1, result.ProvinceMetadata.Length, "Should have metadata for 1 province");

                    var metadata = result.ProvinceMetadata[0];
                    Assert.AreEqual(size * size, metadata.PixelCount, $"Should count all {size * size} pixels");

                    Debug.Log($"Metadata generation for {size}x{size} province took {stopwatch.ElapsedMilliseconds}ms");

                    // Performance expectation (benchmark)
                    Assert.Less(stopwatch.ElapsedMilliseconds, 1000, "Should complete within 1 second");
                }
                finally
                {
                    result.Dispose();
                }
            }
            finally
            {
                pixels.Dispose();
            }
        }

        [Test]
        public void GenerateMetadata_MultipleProvinces_ShouldHandleAll()
        {
            // Create a 4x4 grid with 4 different provinces (one in each quadrant)
            // Layout:
            // 1 1 2 2
            // 1 1 2 2
            // 3 3 4 4
            // 3 3 4 4
            const int width = 4, height = 4;
            var pixels = new NativeArray<ProvinceMapLoader.ProvincePixel>(width * height, Allocator.Temp);

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    int index = y * width + x;
                    ushort provinceID = (ushort)(((y < 2) ? 0 : 2) + ((x < 2) ? 1 : 2));

                    Color32 color = provinceID switch
                    {
                        1 => Color.red,
                        2 => Color.green,
                        3 => Color.blue,
                        4 => Color.yellow,
                        _ => Color.black
                    };

                    pixels[index] = new ProvinceMapLoader.ProvincePixel
                    {
                        Position = new int2(x, y),
                        ProvinceID = provinceID,
                        Color = color
                    };
                }
            }

            try
            {
                var result = ProvinceMetadataGenerator.GenerateMetadata(pixels, width, height, 4);

                try
                {
                    Assert.IsTrue(result.Success, "Multiple province metadata generation should succeed");
                    Assert.AreEqual(4, result.ProvinceMetadata.Length, "Should have metadata for 4 provinces");

                    // Check that all provinces are present
                    var foundProvinces = new System.Collections.Generic.HashSet<ushort>();
                    foreach (var metadata in result.ProvinceMetadata)
                    {
                        foundProvinces.Add(metadata.ID);
                        Assert.AreEqual(4, metadata.PixelCount, $"Province {metadata.ID} should have 4 pixels (2x2)");
                    }

                    Assert.IsTrue(foundProvinces.Contains(1), "Should find province 1");
                    Assert.IsTrue(foundProvinces.Contains(2), "Should find province 2");
                    Assert.IsTrue(foundProvinces.Contains(3), "Should find province 3");
                    Assert.IsTrue(foundProvinces.Contains(4), "Should find province 4");

                    Debug.Log($"Successfully processed {result.ProvinceMetadata.Length} provinces");
                }
                finally
                {
                    result.Dispose();
                }
            }
            finally
            {
                pixels.Dispose();
            }
        }

        [Test]
        public void ProvinceMetadata_Dispose_ShouldCleanupProperly()
        {
            // Create a simple province to generate metadata
            const int width = 2, height = 2;
            var pixels = new NativeArray<ProvinceMapLoader.ProvincePixel>(width * height, Allocator.Temp);

            for (int i = 0; i < width * height; i++)
            {
                pixels[i] = new ProvinceMapLoader.ProvincePixel
                {
                    Position = new int2(i % width, i / width),
                    ProvinceID = 1,
                    Color = Color.red
                };
            }

            try
            {
                var result = ProvinceMetadataGenerator.GenerateMetadata(pixels, width, height, 1);

                if (result.Success && result.ProvinceMetadata.Length > 0)
                {
                    var metadata = result.ProvinceMetadata[0];

                    // Verify that convex hull is created
                    if (metadata.ConvexHull.IsCreated)
                    {
                        Assert.Greater(metadata.ConvexHull.Length, 0, "Should have convex hull points");
                    }

                    // Dispose should not throw and should clean up native arrays
                    Assert.DoesNotThrow(() => result.Dispose(), "Dispose should not throw");

                    // After disposal, accessing native arrays should be invalid
                    // (This is more of a documentation test - in release builds this might not throw)
                    Debug.Log("Metadata disposal test completed successfully");
                }
                else
                {
                    result.Dispose();
                }
            }
            finally
            {
                pixels.Dispose();
            }
        }
    }
}