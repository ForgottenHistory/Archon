// Compute shader for GPU-based province neighbor detection
// Processes millions of pixels in parallel instead of sequential CPU scanning

#pragma kernel DetectNeighbors
#pragma kernel CalculateBounds
#pragma kernel FindCoastalProvinces

// Input textures
Texture2D<float2> ProvinceIDTexture;  // R16G16 format: R=low bits, G=high bits of province ID
int2 TextureSize;                     // Width, Height of the texture

// Output buffers
RWStructuredBuffer<uint2> NeighborPairs;      // Pairs of neighboring province IDs
RWStructuredBuffer<int> NeighborPairCount;     // Atomic counter for pairs
RWStructuredBuffer<int4> ProvinceBounds;       // Min/max bounds per province (x=minX, y=minY, z=maxX, w=maxY)
RWStructuredBuffer<uint> CoastalProvinces;     // List of coastal province IDs
RWStructuredBuffer<int> CoastalProvinceCount;  // Atomic counter for coastal provinces

// Decode province ID from R16G16 format
uint DecodeProvinceID(float2 encoded)
{
    // R channel: bits 0-15, G channel: bits 16-31
    uint lowBits = (uint)(encoded.r * 65535.0);
    uint highBits = (uint)(encoded.g * 65535.0);
    return (highBits << 16) | lowBits;
}

// Thread group size: 8x8 = 64 threads per group
[numthreads(8, 8, 1)]
void DetectNeighbors(uint3 id : SV_DispatchThreadID)
{
    // Check bounds
    if (id.x >= (uint)TextureSize.x || id.y >= (uint)TextureSize.y)
        return;

    int2 coord = int2(id.x, id.y);

    // Get current province ID
    float2 currentEncoded = ProvinceIDTexture[coord];
    uint currentID = DecodeProvinceID(currentEncoded);

    // Skip ocean/wasteland (ID 0)
    if (currentID == 0)
        return;

    // Check right neighbor (horizontal scan)
    if (id.x < (uint)(TextureSize.x - 1))
    {
        int2 rightCoord = int2(id.x + 1, id.y);
        float2 rightEncoded = ProvinceIDTexture[rightCoord];
        uint rightID = DecodeProvinceID(rightEncoded);

        // Found a neighbor boundary
        if (rightID != currentID && rightID != 0)
        {
            // Create sorted pair to avoid duplicates
            uint2 pair = (currentID < rightID) ? uint2(currentID, rightID) : uint2(rightID, currentID);

            // Atomically add to neighbor pairs buffer
            int index;
            InterlockedAdd(NeighborPairCount[0], 1, index);

            if (index < 100000) // Safety limit
            {
                NeighborPairs[index] = pair;
            }
        }

        // Check if coastal (neighbor is ocean)
        if (rightID == 0)
        {
            int coastalIndex;
            InterlockedAdd(CoastalProvinceCount[0], 1, coastalIndex);

            if (coastalIndex < 10000) // Safety limit
            {
                CoastalProvinces[coastalIndex] = currentID;
            }
        }
    }

    // Check bottom neighbor (vertical scan)
    if (id.y < (uint)(TextureSize.y - 1))
    {
        int2 bottomCoord = int2(id.x, id.y + 1);
        float2 bottomEncoded = ProvinceIDTexture[bottomCoord];
        uint bottomID = DecodeProvinceID(bottomEncoded);

        // Found a neighbor boundary
        if (bottomID != currentID && bottomID != 0)
        {
            // Create sorted pair to avoid duplicates
            uint2 pair = (currentID < bottomID) ? uint2(currentID, bottomID) : uint2(bottomID, currentID);

            // Atomically add to neighbor pairs buffer
            int index;
            InterlockedAdd(NeighborPairCount[0], 1, index);

            if (index < 100000) // Safety limit
            {
                NeighborPairs[index] = pair;
            }
        }

        // Check if coastal (neighbor is ocean)
        if (bottomID == 0)
        {
            int coastalIndex;
            InterlockedAdd(CoastalProvinceCount[0], 1, coastalIndex);

            if (coastalIndex < 10000) // Safety limit
            {
                CoastalProvinces[coastalIndex] = currentID;
            }
        }
    }
}

// Calculate bounding boxes for each province
[numthreads(8, 8, 1)]
void CalculateBounds(uint3 id : SV_DispatchThreadID)
{
    // Check bounds
    if (id.x >= (uint)TextureSize.x || id.y >= (uint)TextureSize.y)
        return;

    int2 coord = int2(id.x, id.y);

    // Get current province ID
    float2 currentEncoded = ProvinceIDTexture[coord];
    uint provinceID = DecodeProvinceID(currentEncoded);

    // Skip ocean/wasteland
    if (provinceID == 0 || provinceID >= 65535)
        return;

    // Atomically update min/max bounds for this province
    InterlockedMin(ProvinceBounds[provinceID].x, (int)id.x);
    InterlockedMin(ProvinceBounds[provinceID].y, (int)id.y);
    InterlockedMax(ProvinceBounds[provinceID].z, (int)id.x);
    InterlockedMax(ProvinceBounds[provinceID].w, (int)id.y);
}

// Find all coastal provinces (provinces that border ocean)
[numthreads(8, 8, 1)]
void FindCoastalProvinces(uint3 id : SV_DispatchThreadID)
{
    // Check bounds
    if (id.x >= (uint)TextureSize.x || id.y >= (uint)TextureSize.y)
        return;

    int2 coord = int2(id.x, id.y);

    // Get current province ID
    float2 currentEncoded = ProvinceIDTexture[coord];
    uint currentID = DecodeProvinceID(currentEncoded);

    // Skip if already ocean
    if (currentID == 0)
        return;

    // Check all 4 neighbors for ocean
    bool isCoastal = false;

    // Check right
    if (id.x < (uint)(TextureSize.x - 1))
    {
        float2 neighborEncoded = ProvinceIDTexture[int2(id.x + 1, id.y)];
        if (DecodeProvinceID(neighborEncoded) == 0)
            isCoastal = true;
    }

    // Check left
    if (id.x > 0 && !isCoastal)
    {
        float2 neighborEncoded = ProvinceIDTexture[int2(id.x - 1, id.y)];
        if (DecodeProvinceID(neighborEncoded) == 0)
            isCoastal = true;
    }

    // Check bottom
    if (id.y < (uint)(TextureSize.y - 1) && !isCoastal)
    {
        float2 neighborEncoded = ProvinceIDTexture[int2(id.x, id.y + 1)];
        if (DecodeProvinceID(neighborEncoded) == 0)
            isCoastal = true;
    }

    // Check top
    if (id.y > 0 && !isCoastal)
    {
        float2 neighborEncoded = ProvinceIDTexture[int2(id.x, id.y - 1)];
        if (DecodeProvinceID(neighborEncoded) == 0)
            isCoastal = true;
    }

    // If coastal, add to list
    if (isCoastal)
    {
        int index;
        InterlockedAdd(CoastalProvinceCount[0], 1, index);

        if (index < 10000) // Safety limit
        {
            CoastalProvinces[index] = currentID;
        }
    }
}